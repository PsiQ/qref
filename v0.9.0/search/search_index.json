{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QREF","text":"<p>Quantum Resource Estimation Format (QREF) is an open format for representing quantum algorithms, optimized for usage in quantum resource estimation (QRE).</p> <ul> <li> <p> It's just JSON (or YAML)</p> <p>QREF's data format is built on top of JSON, which makes it easy to write and read.</p> <p> Learn more</p> </li> <li> <p> Cross-language support</p> <p>QREF's JSON schema can be used for data validation in any language.</p> </li> <li> <p> Python library</p> <p>QREF's Python package provides programmatic access to QREF's JSON schema and ready-to-use Pydantic models.</p> <p> See user guide</p> </li> <li> <p> Open Source, Apache 2.0</p> <p>QREF is licensed under the Apache 2.0 license and lives on GitHub.</p> <p> See QREF on GH\u00a0\u29c9</p> </li> </ul>"},{"location":"design/","title":"Design choices","text":""},{"location":"design/#using-lists-instead-of-mappings","title":"Using lists instead of mappings","text":"<p>One of the most controversial choices we have made in QREF is the choice of using lists instead of mappings (a.k.a. dictionaries) for objects that should have an unique name. This choice affects:</p> <ul> <li>Children of a <code>Routine</code>.</li> <li>Ports of a <code>Routine</code>.</li> </ul> <p>For instance, why did we chose to represent ports like this:</p> <pre><code>ports:\n  - {\"name\": \"in_0\", \"direction\": \"input\", \"size\": 2},\n  - {\"name\": \"out_0\", \"direction\": \"output\", \"size\": \"N\"}\n</code></pre> <p>instead of this:</p> <p><pre><code>ports:\n  in_0: {\"direction\": \"input\", \"size\": 2}\n  out_0: {\"direction\": \"output\", \"size\": \"N\"}\n</code></pre> ?</p> <p>The answer is purely pragmatic. On the one hand, using mappings instead of lists would guarantee uniqueness of names of ports and children. But, on the other hand, it would give a false sense of security. To see why, consider the following example Python code, which loads an incorrect definition of ports:</p> <pre><code>import yaml\n\ndata = \"\"\"\nports:\n  in_0: {\"direction\": \"input\", \"size\": 2}\n  in_0: {\"direction\": \"input\", \"size\": \"N\"}\n\"\"\"\n\nprint(yaml.safe_load(data))\n</code></pre> <p>If you are new to parsing YAML (or JSON) in Python you might be surprised that the code runs at all - after all shouldn't keys in YAML mappings be unique? Well they should, but most parsers will just load the last key if the duplicates are present. The code above prints:</p> <pre><code>{'ports': {'in_0': {'direction': 'input', 'size': 'N'}}}\n</code></pre> <p>So, suppose you are editing a QREF file. You made a mistake and used the same port name twice. If we used mapping, your file would load fine, but you would lose one entry. Importantly, from your code's perspective you wouldn't even know - you would just get a dictionary with unique keys. Debugging problems that could arise in this way would be a nightmare, and we want to save all of us such hurdles.</p> <p>Now, what happens if we use lists? Let's try the following code:</p> <pre><code>import yaml\n\ndata = \"\"\"\nports:\n  - {\"name\": \"in_0\", \"direction\": \"input\", \"size\": 2}\n  - {\"name\": \"in_0\", \"direction\": \"input\", \"size\": \"N\"}\n\"\"\"\n\nprint(yaml.safe_load(data))\n</code></pre> <p>This time, we get the following output: <pre><code>{'ports': [{'name': 'in_0', 'direction': 'input', 'size': 2}, {'name': 'in_0', 'direction': 'input', 'size': 'N'}]}\n</code></pre> Now, we have ports with duplicate names, which is not good, but we are able to detect this and react e.g. by raising exception. No information was lost.</p> <p>The natural question to ask is: why won't we use dictionaries, and handle duplicate keys by customizing YAML (or JSON) parsers? We could do this, but keep in mind that QREF is mainly a data format. Different users can use different parsers and we want to make sure everyone gets consistent results no matter what parsing library they use.</p>"},{"location":"design/#why-isnt-routine-a-top-level-object","title":"Why isn't routine a top level object?","text":"<p>The actual program you are representing in QREF is stored as <code>program</code> property of a top-level schema object, i.e.</p> <p><pre><code>version: v1\nprogram:\n  name: my_program\n  children:\n    # ... \n</code></pre> You might wonder why wouldn't we just make the program a top-level object, or, in other words, why don't QREF documents look like this instead:</p> <pre><code>version: v1\nname: my_program\nchildren:\n  # ...\n</code></pre> <p>There are essentially two reasons, but both of them have to do with the fact that we wanted our structure to be recursive.</p> <p>To quickly explain what recursive in this context means, let's think about <code>program</code> and its <code>children</code>. Both of them can be viewed as objects of the same type. The <code>program</code> is a routine which can contain other routines as its <code>children</code>. Each of the children can have other routines as their children etc. It's routines all the way down.</p> <p>Now, if we used a top-level object to represent a program, we face a problem - we need to include version only in this object and not in the children. Therefore we would have to create a separate type for the main program and separate one for subroutines. This would have the following consequences, listed in the order of importance:</p> <ul> <li>The JSON schema would no longer be recursive, and thus   would contain more definitions, which simply means   it would be more complex and harder to read.</li> <li>The hierarchy of our Pydantic models would get slightly   more complex.</li> </ul> <p>We don't mind putting effort into creating more complex hierarchy of models if it would add usability. However, we think that having the JSON schema as simple as possible is beneficial to the users (especially considering that QREF is mostly a data format!), and thus we made a choice of using the recursive type hierarchy.</p>"},{"location":"development/","title":"Development guide","text":""},{"location":"development/#setting-up-development-environment","title":"Setting up development environment","text":"<p>QREF uses Poetry\u00a0\u29c9 for managing dependencies. Therefore, we recommend you use Poetry to setup your environment. However, if you insist on not using Poetry, the more traditional way of using editable install with <code>pip</code> is still avaiable.</p>"},{"location":"development/#using-editable-install-with-poetry","title":"Using editable install with Poetry","text":"<p>To setup your development environment install poetry (if you don't have it yet):</p> <pre><code>pip install poetry\n</code></pre> <p>And then install the project and its dependencies:</p> <pre><code>poetry install\n</code></pre>"},{"location":"development/#using-editable-install-with-pip","title":"Using editable install with pip","text":"<p>You can also develop Poetry using <code>pip</code>:</p> <pre><code>pip install -e .\n</code></pre> <p>Warning</p> <p>If you are planning to add/modify dependencies of QREF, we highly recommend you use Poetry instead of pip editable install. Without Poetry, you will need to edit dependencies manually, which is very error-prone.</p>"},{"location":"development/#setting-up-docs-locally","title":"Setting up docs locally","text":"<p>In order to set up docs locally you need to have appropriate dependencies \u2013\u00a0they get instaled when running <code>poetry install</code> automatically. When done, please run:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"format/","title":"Data format","text":""},{"location":"format/#introduction","title":"Introduction","text":"<p>QREF format is a domain-specific language (DSL) for describing quantum algorithms built on top of JSON for the purpose of resource estimation.</p> <p>In QREF, the algorithms are described as programs comprising hierarchical, directed acyclic graph (henceforth hierarchical DAGs) of subroutines. Let's break down what this means:</p> <ul> <li>Hierarchical means that routines can be nested.</li> <li>Directed means that every edge connecting two routines also defines in which   direction the information flows between them.</li> <li>Acyclic means that traversing the graph along its edges (respecting their direction)   will never lead to visiting the same node twice.</li> </ul> <p>Besides specifying the connectivity between routines in the algorithms, the QREF format also specifies how to store information relevant to resource estimation, such as known and unknown resources, parameters that might affect them and how the parameters propagate in the algorithm's graph.</p> <p>Before describing the format in detail, let us first exemplify its usage on a simple program.</p>"},{"location":"format/#basic-example","title":"Basic example","text":"<p>In QREF, the quantum programs are represented as graphs. If you are not used to representing computations as graph, don't worry! Before describing QREF format, we'll demostrate how a simple circuit can be represented as a graph.</p> <p>Consider a hypothetical quantum program as depicted in the following circuit.</p> <p></p> <p>Let's forget for a while that the depicted algorithm doesn't make much sense. We can see that the circuit comprises two subroutines:</p> <ul> <li><code>subroutine_1</code> operating on a single-qubit register.</li> <li><code>subroutine_2</code> operating on a two-qubit register.</li> </ul> <p>We also labelled inputs to the subroutines as <code>in_0</code> and <code>in_1</code>, and the whole output of our program (i.e. combined outputs of both subroutines) as <code>out</code>.</p> <p>Representing such a circuit as a graph is straightforward, it might look like this:</p> <p></p> <p>As we can see, the graph contains both subroutines form the original circuit, and an artificially introduced <code>merge</code> operation used to combine outputs from the subprograms into one final outputs.</p> <p>Now that we have our graph, let's see how it can be represented in QREF format. As already mentioned, QREF format is built on top of JSON, so we can write QREF files in either JSON or YAML. For our examples, those might look as follows:</p> YAMLJSON <pre><code>version: v1\nprogram:\n  name: my_program\n  ports:\n    - { direction: input, name: in_0, size: 1 }\n    - { direction: input, name: in_1, size: 2 }\n    - { direction: output, name: out, size: 3 }\n  children:\n    - name: subroutine_1\n      ports:\n        - { direction: input, name: in, size: 1 }\n        - { direction: output, name: out, size: 1 }\n    - name: subroutine_2\n      ports:\n        - { direction: input, name: in, size: 2 }\n        - { direction: output, name: out, size: 2 }\n    - name: merge\n      ports:\n        - { direction: input, name: in_0, size: 1 }\n        - { direction: input, name: in_1, size: 2 }\n        - { direction: output, name: out, size: 3 }\n  connections:\n    - { source: in_0, target: subroutine_1.in }\n    - { source: in_1, target: subroutine_2.in }\n    - { source: subroutine_1.out, target: merge.in_1 }\n    - { source: subroutine_2.out, target: merge.in_0 }\n    - { source: merge.out, target: out }\n</code></pre> <pre><code>{\n  \"version\": \"v1\",\n  \"program\": {\n    \"name\": \"my_program\",\n    \"ports\": [\n      {\n        \"direction\": \"input\",\n        \"name\": \"in_0\",\n        \"size\": 1\n      },\n      {\n        \"direction\": \"input\",\n        \"name\": \"in_1\",\n        \"size\": 2\n      },\n      {\n        \"direction\": \"output\",\n        \"name\": \"out\",\n        \"size\": 3\n      }\n    ],\n    \"children\": [\n      {\n        \"name\": \"subroutine_1\",\n        \"ports\": [\n          {\n            \"direction\": \"input\",\n            \"name\": \"in\",\n            \"size\": 1\n          },\n          {\n            \"direction\": \"output\",\n            \"name\": \"out\",\n            \"size\": 1\n          }\n        ]\n      },\n      {\n        \"name\": \"subroutine_2\",\n        \"ports\": [\n          {\n            \"direction\": \"input\",\n            \"name\": \"in\",\n            \"size\": 2\n          },\n          {\n            \"direction\": \"output\",\n            \"name\": \"out\",\n            \"size\": 2\n          }\n        ]\n      },\n      {\n        \"name\": \"merge\",\n        \"ports\": [\n          {\n            \"direction\": \"input\",\n            \"name\": \"in_0\",\n            \"size\": 1\n          },\n          {\n            \"direction\": \"input\",\n            \"name\": \"in_1\",\n            \"size\": 2\n          },\n          {\n            \"direction\": \"output\",\n            \"name\": \"out\",\n            \"size\": 3\n          }\n        ]\n      }\n    ],\n    \"connections\": [\n      {\n        \"source\": \"in_0\",\n        \"target\": \"subroutine_1.in\"\n      },\n      {\n        \"source\": \"in_1\",\n        \"target\": \"subroutine_2.in\"\n      },\n      {\n        \"source\": \"subroutine_1.out\",\n        \"target\": \"merge.in_1\"\n      },\n      {\n        \"source\": \"subroutine_2.out\",\n        \"target\": \"merge.in_0\"\n      },\n      {\n        \"source\": \"merge.out\",\n        \"target\": \"out\"\n      }\n    ]\n  }\n}\n</code></pre> <p>Let's dissect our example. The top-level object has two mandatory properties:</p> <ul> <li><code>version</code>: Set to <code>v1</code> (which is the only version so far)</li> <li><code>program</code>: This contains the actual description of the program.</li> </ul> <p>So what do we have in a <code>program</code> object?</p> <ul> <li><code>name</code>: Mandatory name of the program, here set to the string <code>my_program</code>.</li> <li><code>ports</code>: A collection of ports. They roughly correspond to quantum registers.</li> <li><code>children</code>: A list of children, or subroutines, of the program.</li> <li><code>connections</code>: A list defining edges of our graph.</li> </ul>"},{"location":"format/#ports","title":"Ports","text":"<p>Let us first take a look at ports, like the first input port of our program:</p> <pre><code>{direction: input, name: in_0, size: 1}\n</code></pre> <p>Ports, like most other components in QREF, have names, which should be distinct among all ports of any given program (or subroutine). Each port also has direction, which can be either <code>input</code>, <code>output</code> or <code>through</code> (for ports serving as both input and output). Finally, each port has size. In our simple scenario, all sizes are positive integers. However, QREF is not limited to them, and size of a port can be either:</p> <ul> <li>A positive integer.</li> <li>A symbol or symbolic expression (e.g. <code>N</code> or <code>2L + 1</code>)</li> <li>A <code>null</code>, signifying that the size of the port can be deduced from sizes of   other ports it is connected to (possibly transitively).</li> </ul>"},{"location":"format/#children","title":"Children","text":"<p>The <code>children</code> list comprises all subroutines of the program. Each entry has the same structure as the program itself (one could say that the schema of the <code>program</code> is recursive). In particular, each child should have a name (unique in the scope of their immediate parent) and some ports. They can also have connections, and their  own children.</p>"},{"location":"format/#connections","title":"Connections","text":"<p>The last component of any program (and most subroutines) are connections defining the edges of a graph. The <code>connections</code> field is a list of objects, each having <code>source</code> and <code>target</code>. Both <code>source</code> and <code>target</code> can either be:</p> <ul> <li>A name of the port of the program/subroutine the connection belongs to, i.e. <code>out_0</code></li> <li>A reference to a port of one of program/subroutine's direct children.   Such a reference is formatted as <code>child.port_name</code>.</li> </ul> <p>There are three types of connections:</p> <ul> <li>Connections joining two distinct children, e.g.   <pre><code>{source: subroutine_1.out, target: merge.in_1}\n</code></pre></li> <li>Connections joining a child and its parent. e.g.:   <pre><code>{source: in_0, target: subroutine_1.in}\n</code></pre>   or   <pre><code>{source: merge.out, target: out}\n</code></pre></li> <li>Connections joining input and output port of a parent, known as passthroughs.   There are no passthroughs in our simple example, but one could look like:   <pre><code>{source: in_0, target: out}\n</code></pre></li> </ul> <p>Writing connections in this way migh be cumbersome. However, there exists an alternative, more concise syntax. Instead writing:</p> <p><pre><code>{source: a.out, target: b.in}\n</code></pre> you can write: <pre><code>\"a.out -&gt; b.in\"\n</code></pre></p> <p>With this concise notation, the example program we've seen at the very beginning looks as follows:</p> YAML <pre><code>version: v1\nprogram:\n  name: my_program\n  ports:\n    - { direction: input, name: in_0, size: 1 }\n    - { direction: input, name: in_1, size: 2 }\n    - { direction: output, name: out, size: 3 }\n  children:\n    - name: subroutine_1\n      ports:\n        - { direction: input, name: in, size: 1 }\n        - { direction: output, name: out, size: 1 }\n    - name: subroutine_2\n      ports:\n        - { direction: input, name: in, size: 2 }\n        - { direction: output, name: out, size: 2 }\n    - name: merge\n      ports:\n        - { direction: input, name: in_0, size: 1 }\n        - { direction: input, name: in_1, size: 2 }\n        - { direction: output, name: out, size: 3 }\n  connections:\n    - \"in_0 -&gt; subtourine_1.in\"\n    - \"in_1 -&gt; subroutine_2.in\"\n    - \"subroutine_1.out -&gt; merge.in_1\"\n    - \"subroutine_2.out -&gt; merge.in_0\"\n    - \"merge.out -&gt; out\"\n</code></pre>"},{"location":"format/#repetitions","title":"Repetitions","text":"<p>On top of the basic fileds listed above, one can also write a QREF routine which contains repetitions.</p> <p>This can be added with <code>repetition</code> field:</p> <pre><code>repetition:\n  count: ceil(1/eps)\n  sequence:\n    type: constant\n    multiplier: 1\n</code></pre> <p><code>repetition</code> consists of two parts:</p> <ul> <li><code>count</code> \u2013 defines how many times the child of the this routine should be repeated.</li> <li><code>sequence</code> \u2013\u00a0defines how the costs for the repetition will be aggregated. Each <code>sequence</code> has a field <code>type</code> which defines the type of the sequence. Depending on the type there are extra fields, summarized in the table below.</li> </ul> <p>There are 5 different sequences that one can currently use in QREF:</p> Sequence type Additional fields Description Example <code>constant</code> <code>multiplier</code> In each iteration child is repeated <code>multiplier</code> number of times. Trotterization <code>arithmetic</code> <code>difference</code>, <code>initial_term</code> Iteration starts from <code>initial_term</code> repetitions of a child and then we increase the of repetitions by <code>difference</code> in every iteration. QFT <code>geometric</code> <code>ratio</code> In each iteration number of repetitions is multiplied by <code>ratio</code>, starts for 1 repetition in the first iteartion. QPE <code>closed_form</code> <code>sum</code>, <code>prod</code>, <code>num_terms_symbol</code> This can be used for cases, where we know the closed-form expression for the total cost of the routine given the number of repetitions is defined <code>num_terms_symbol</code>. <code>sum</code> is an expression for additive resources and <code>prod</code> is for multiplicative. Any <code>custom</code> <code>term_expression</code>, <code>iterator_symbol</code> This can be used in case where we don't know the formula for closed form, but we do know the formula for each term, which is defined using <code>term_expression</code>, and we use <code>iterator_symbol</code> to denote the iterator. Any <p>This representation abstracts out certain implementation details. Consider implementation of QPE using geometric sequence below. The child <code>U</code> of routine <code>Evolution</code> has two ports: <code>result</code> and <code>psi</code>, the with sizes <code>bits_of_precision</code> and  <code>N</code>. Even though in the executable implementation each next controlled <code>U^2^i</code> only acts on one control qubit from the <code>result</code> register, there's currently no way of expressing it in QREF.</p> YAML <pre><code>description: Program representing QPE using geometric sequence\ninput:\n  program:\n    children:\n    - name: Hadamards\n      ports:\n      - direction: through\n        name: register\n        size: N\n    - name: Evolution\n      ports:\n      - direction: input\n        name: result_in\n        size: bits_of_precision\n      - direction: output\n        name: result_out\n        size: N\n      - direction: input\n        name: psi_in\n        size: None\n      - direction: output\n        name: psi_out\n        size: None\n      children:\n      - name: U\n        ports:\n        - direction: through\n          name: result\n          size: bits_of_precision\n        - direction: through\n          name: psi\n          size: N\n        resources:\n        - name: T_gates\n          type: additive\n          value: N**2\n      connections:\n      - source: result_in\n        target: U.result\n      - source: U.result\n        target: result_out\n      - source: psi_in\n        target: U.psi\n      - source: U.psi\n        target: psi_out\n      repetition:\n        count: bits_of_precision\n        sequence:\n          type: geometric\n          ratio: 1\n    - name: Inverse_QFT\n      ports:\n      - direction: through\n        name: register\n        size: N\n    connections:\n    - source: result_in\n      target: Hadamards.register\n    - source: Hadamards.register\n      target: Evolution.result_in\n    - source: Evolution.result_out\n      target: Inverse_QFT.register\n    - source: Inverse_QFT.register\n      target: result_out\n    - source: psi_in\n      target: Evolution.psi_in\n    - source: Evolution.psi_out\n      target: psi_out\n    name: QPE\n    ports:\n    - direction: input\n      name: result_in\n      size: ceil(log2(1/eps))\n    - direction: output\n      name: result_out\n      size: ceil(log2(1/eps))\n    - direction: input\n      name: psi_in\n      size: M\n    - direction: output\n      name: psi_out\n      size: M\n\n  version: v1\n</code></pre>"},{"location":"library/userguide/","title":"User guide","text":""},{"location":"library/userguide/#installation","title":"Installation","text":"<p>To install QREF Python package, clone QREF repository and install it as usual with <code>pip</code>:</p> <pre><code># Clone QREF repo (you can use HTTP link as well)\ngit clone git@github.com:PsiQ/qref.git\ncd qref\npip install .\n</code></pre> <p>Please note that to use rendering features you need a working graphviz\u00a0\u29c9 installation.</p>"},{"location":"library/userguide/#usage","title":"Usage","text":""},{"location":"library/userguide/#using-json-schema-for-validating-data-in-qref-format","title":"Using JSON schema for validating data in QREF format","text":"<p>JSON schema for QREF format can be obtained by calling <code>generate_program_schema</code> function. Such schema can be then used for validating user's input, e.g. using <code>jsonschema</code>\u00a0\u29c9 package:</p> <pre><code>from jsonschema import validate\nfrom qref import generate_program_schema\n\n# Hypothetical function loading your data as native Python dictionary.\ndata = load_some_program()\nschema = generate_program_schema()\n\n# This will raise if there are some validation errors.\nvalidate(schema, data)\n</code></pre>"},{"location":"library/userguide/#validation-using-pydantic-models","title":"Validation using Pydantic models","text":"<p>If you are familiar with Pydantic\u00a0\u29c9, you might find it easier to work with QREF Pydantic models instead of interacting with JSON schema directly. In the example below, we create an instance of <code>SchemaV1</code> model from validated data stored in QREF format:</p> <pre><code>from qref import SchemaV1\n\ndata = load_some_program()\n\n# This will raise if data is not valid\nprogram = SchemaV1.model_validate(data)\n</code></pre> <p>One of the benefits of using QREF's pydantic models is ability to obtain objects like children, ports or resources by name, instead of list indices. This is done by special <code>.by_name</code> accessor. For instance to get a child named <code>\"foo\"</code> of a <code>routine</code> object, one can use the following syntax:</p> <pre><code>foo = routine.children.by_name[\"foo\"]\n</code></pre>"},{"location":"library/userguide/#topology-validation","title":"Topology validation","text":"<p>There can be cases where a program is correct from the perspective of Pydantic validation, but has incorrect topology. This includes cases such as:</p> <ul> <li>Disconnected ports</li> <li>Ports with multiple connections</li> <li>Cycles in the graph</li> </ul> <p>In order to validate whether the topology of the program is correct you can use <code>verify_topology</code> method. Here's a short snippet showing how one can verify their program and print out the problems (if any).</p> <pre><code>from qref.verification import verify_topology\n\nprogram = load_some_program()\n\nverification_output = verify_topology(program)\n\nif not verification_output:\n    print(\"Program topology is incorrect, due to the following issues:\")\n    for problem in verification_output.problems:\n        print(problem)\n</code></pre>"},{"location":"library/userguide/#topology-validation_1","title":"Topology validation","text":"<p>There can be cases where a program is correct from the perspective of Pydantic validation, but has incorrect topology. This includes cases such as:</p> <ul> <li>Disconnected ports</li> <li>Ports with multiple connections</li> <li>Cycles in the graph</li> </ul> <p>In order to validate whether the topology of the program is correct you can use <code>verify_topology</code> method. Here's a short snippet showing how one can verify their program and print out the problems (if any).</p> <pre><code>from qref.verification import verify_topology\n\nprogram = load_some_program()\n\nverification_output = verify_topology(program)\n\nif not verification_output:\n    print(\"Program topology is incorrect, due to the following issues:\")\n    for problem in verification_output.problems:\n        print(problem)\n</code></pre>"},{"location":"library/userguide/#rendering-qref-files-using-qref-render-experimental","title":"Rendering QREF files using <code>qref-render</code> (experimental)","text":"<p>Warning</p> <p>This feature is considered experimental and may occassionally produce  incorrect results.</p> <p>QREF comes with a CLI tool for rendering hierarchical graphs of quantum algorithms. To render an algorithm stored in a file named <code>my_program.yaml</code> into a  file <code>my_program_graph.svg</code> run:</p> <pre><code>qref-render my_program.yaml my_program_graph.svg\n</code></pre> <p>The <code>qref-render</code> tool supports <code>yaml</code> and <code>json</code> input formats, and all output formats supported by graphviz\u00a0\u29c9.</p> <p>If you prefer to use QREF's rendering capabilities from a Python script instead of the CLI, you can use the <code>qref.experimental.rendering</code> module,  which performs the same task as <code>qref-render</code>. Here, we demonstrate how to use the rendering module to visualize quantum circuits for preparing arbitrary quantum states in alias sampling. To learn more about the algorithm, please refer to the tutorial for Bartiq\u00a0\u29c9 \u2013 our library for symbolic resource estimation.</p> <p>We will use the <code>yaml</code> file <code>alias_sampling.yaml</code> as input to generate a graph representing this algorithm:</p> <p><pre><code>import yaml\nfrom qref import SchemaV1\nfrom qref.experimental.rendering import to_graphviz\n\n# Load the YAML file\nwith open(\"../examples/alias_sampling.yaml\", \"r\") as f:\n    data = yaml.safe_load(f)\n\n# Validate the schema and convert to Graphviz object\nprogram = SchemaV1.model_validate(data)\ngv_object = to_graphviz(program)\n\n# Render the Graphviz object to a PNG file\ngv_object.render(\"alias_sampling\", format=\"png\")\n</code></pre> </p>"},{"location":"library/reference/qref.experimental.rendering/","title":"qref.experimental.rendering","text":""},{"location":"library/reference/qref.experimental.rendering/#qref.experimental.rendering","title":"qref.experimental.rendering","text":"<p>Experimental visualization capabilities for QREF.</p> <p>Currently, the visualizations are done with graphviz, which does not suport hierarchical structures. Therefore, we have to use a somewhat hacky representation of our routines:</p> <ul> <li>The leaf nodes are drawn as a single graphviz node (this is not surprising) with   Mrecord shape. This allows to visually separate routine name from its ports.</li> <li>The non-leaf nodes are represented as clusters.</li> <li>Clusters can't use Mrecord shape, and so the ports are drawn as separate nodes.</li> <li>Input and output ports are grouped into subgraphs with the same rank, which     forces all inputs / all outputs to be placed in a single column.</li> </ul> <p>Because of the above dichotomy, care has to be taken when constructing edges. - If addressing port of a leaf, it must be specified as graphviz port, e.g:   \"root.child:in_0\" - If addressing port of a non-leaf, you use normal node reference, e.g:   \"root.child.in_0\"</p>"},{"location":"library/reference/qref.experimental.rendering/#qref.experimental.rendering.GRAPH_ATTRS","title":"GRAPH_ATTRS  <code>module-attribute</code>","text":"<pre><code>GRAPH_ATTRS = {\n    \"rankdir\": \"LR\",\n    \"fontname\": \"Helvetica\",\n    \"splines\": \"false\",\n}\n</code></pre>"},{"location":"library/reference/qref.experimental.rendering/#qref.experimental.rendering.LEAF_NODE_KWARGS","title":"LEAF_NODE_KWARGS  <code>module-attribute</code>","text":"<pre><code>LEAF_NODE_KWARGS = {\n    \"shape\": \"Mrecord\",\n    \"style\": \"bold\",\n    \"color\": \"#0288f5\",\n    \"fontsize\": \"12\",\n}\n</code></pre>"},{"location":"library/reference/qref.experimental.rendering/#qref.experimental.rendering.PORT_NODE_KWARGS","title":"PORT_NODE_KWARGS  <code>module-attribute</code>","text":"<pre><code>PORT_NODE_KWARGS = {\n    \"style\": \"bold\",\n    \"color\": \"#ffa44a\",\n    \"fontsize\": \"10\",\n    \"shape\": \"circle\",\n}\n</code></pre>"},{"location":"library/reference/qref.experimental.rendering/#qref.experimental.rendering.PORT_GROUP_ATTRS","title":"PORT_GROUP_ATTRS  <code>module-attribute</code>","text":"<pre><code>PORT_GROUP_ATTRS = {'rank': 'same'}\n</code></pre>"},{"location":"library/reference/qref.experimental.rendering/#qref.experimental.rendering.CLUSTER_KWARGS","title":"CLUSTER_KWARGS  <code>module-attribute</code>","text":"<pre><code>CLUSTER_KWARGS = {'style': 'rounded'}\n</code></pre>"},{"location":"library/reference/qref.experimental.rendering/#qref.experimental.rendering.to_graphviz","title":"to_graphviz","text":"<pre><code>to_graphviz(routine: RoutineV1) -&gt; graphviz.Digraph\n</code></pre> <p>Convert routine encoded with v1 schema to a graphviz DAG.</p> Source code in <code>src/qref/experimental/rendering.py</code> <pre><code>@accepts_all_qref_types\ndef to_graphviz(routine: RoutineV1) -&gt; graphviz.Digraph:\n    \"\"\"Convert routine encoded with v1 schema to a graphviz DAG.\"\"\"\n    dag = graphviz.Digraph(graph_attr=GRAPH_ATTRS)\n    _add_routine(ensure_routine(routine), dag)\n    return dag\n</code></pre>"},{"location":"library/reference/qref.experimental.rendering/#qref.experimental.rendering.render_entry_point","title":"render_entry_point","text":"<pre><code>render_entry_point()\n</code></pre> Source code in <code>src/qref/experimental/rendering.py</code> <pre><code>def render_entry_point():\n    parser = ArgumentParser()\n    parser.add_argument(\"input\", help=\"Path to the YAML or JSON file with Routine in V1 schema\", type=Path)\n    parser.add_argument(\n        \"output\",\n        help=(\n            \"Path to the output file. File format is determined based on the extension, \"\n            \"which should be either .svg or .pdf\"\n        ),\n        type=Path,\n    )\n\n    args = parser.parse_args()\n\n    with open(args.input) as f:\n        routine = SchemaV1.model_validate(yaml.safe_load(f))\n\n    dag = to_graphviz(routine)\n    dag.render(args.output.with_suffix(\"\"), format=args.output.suffix.strip(\".\"))\n</code></pre>"},{"location":"library/reference/qref.functools/","title":"qref.functools","text":""},{"location":"library/reference/qref.functools/#qref.functools","title":"qref.functools","text":"<p>Tools for constructing functions operating on Qref objects.</p>"},{"location":"library/reference/qref.functools/#qref.functools.ensure_routine","title":"ensure_routine","text":"<pre><code>ensure_routine(data: AnyQrefType) -&gt; RoutineV1\n</code></pre> <p>Ensure that given objects is of RoutineV1 type.</p> <p>This functions may serve for constructing functions accepting either RoutineV1 oor SchemaV1 objects, as well as dictionaries that represent them.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>AnyQrefType</code> <p>the objects that has to be converted (if neccessary) to RoutineV1. Can either be</p> required <p>Returns:</p> Type Description <code>RoutineV1</code> <p>An object of type RoutineV1 corresponding to the provided data.</p> Source code in <code>src/qref/functools.py</code> <pre><code>@singledispatch\ndef ensure_routine(data: AnyQrefType) -&gt; RoutineV1:\n    \"\"\"Ensure that given objects is of RoutineV1 type.\n\n    This functions may serve for constructing functions accepting either RoutineV1 oor SchemaV1\n    objects, as well as dictionaries that represent them.\n\n    Args:\n        data: the objects that has to be converted (if neccessary) to RoutineV1. Can either be\n        an instance of SchemaV1, in which case its `program` attribute will be returned,\n        an instance of RoutineV1, in which case the object will be returned without changes,\n        or a dictionary, in which case it will serve to constructe RoutineV1, or SchemaV1.\n\n    Returns:\n        An object of type RoutineV1 corresponding to the provided data.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"library/reference/qref.functools/#qref.functools._ensure_routine_from_dict","title":"_ensure_routine_from_dict","text":"<pre><code>_ensure_routine_from_dict(\n    data: dict[str, Any]\n) -&gt; RoutineV1\n</code></pre> Source code in <code>src/qref/functools.py</code> <pre><code>@ensure_routine.register(dict)\ndef _ensure_routine_from_dict(data: dict[str, Any]) -&gt; RoutineV1:\n    return SchemaV1(**data).program if \"version\" in data else RoutineV1(**data)\n</code></pre>"},{"location":"library/reference/qref.functools/#qref.functools._ensure_routine_from_schema_v1","title":"_ensure_routine_from_schema_v1","text":"<pre><code>_ensure_routine_from_schema_v1(data: SchemaV1) -&gt; RoutineV1\n</code></pre> Source code in <code>src/qref/functools.py</code> <pre><code>@ensure_routine.register\ndef _ensure_routine_from_schema_v1(data: SchemaV1) -&gt; RoutineV1:\n    return data.program\n</code></pre>"},{"location":"library/reference/qref.functools/#qref.functools._ensure_routine_from_routine_v1","title":"_ensure_routine_from_routine_v1","text":"<pre><code>_ensure_routine_from_routine_v1(\n    data: RoutineV1,\n) -&gt; RoutineV1\n</code></pre> Source code in <code>src/qref/functools.py</code> <pre><code>@ensure_routine.register\ndef _ensure_routine_from_routine_v1(data: RoutineV1) -&gt; RoutineV1:\n    return data\n</code></pre>"},{"location":"library/reference/qref.functools/#qref.functools.accepts_all_qref_types","title":"accepts_all_qref_types","text":"<pre><code>accepts_all_qref_types(\n    f: Callable[Concatenate[RoutineV1, P], T]\n) -&gt; Callable[Concatenate[AnyQrefType, P], T]\n</code></pre> <p>Make a callable accepting RoutineV1 as first arg capable of accepting arbitrary QREF object.</p> <p>Here, by arbitrary QREF object we mean either an instance of SchemaV1, an instance of RoutineV1, or any dictionary that can be converted to an instance of SchemaV1 or RoutineV1.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[Concatenate[RoutineV1, P], T]</code> <p>Callable to be augmented.</p> required <p>Returns:</p> Type Description <code>Callable[Concatenate[AnyQrefType, P], T]</code> <p>A new callable preserving behavoiur of f, but also capable of accepting SchemaV1 instance or dicts</p> <code>Callable[Concatenate[AnyQrefType, P], T]</code> <p>as first arguments.</p> Source code in <code>src/qref/functools.py</code> <pre><code>def accepts_all_qref_types(f: Callable[Concatenate[RoutineV1, P], T]) -&gt; Callable[Concatenate[AnyQrefType, P], T]:\n    \"\"\"Make a callable accepting RoutineV1 as first arg capable of accepting arbitrary QREF object.\n\n    Here, by arbitrary QREF object we mean either an instance of SchemaV1, an instance of RoutineV1,\n    or any dictionary that can be converted to an instance of SchemaV1 or RoutineV1.\n\n    Args:\n        f: Callable to be augmented.\n\n    Returns:\n        A new callable preserving behavoiur of f, but also capable of accepting SchemaV1 instance or dicts\n        as first arguments.\n    \"\"\"\n\n    @wraps(f)\n    def _inner(routine: SchemaV1 | RoutineV1 | dict[str, Any], *args: P.args, **kwargs: P.kwargs) -&gt; T:\n        return f(ensure_routine(routine), *args, **kwargs)\n\n    return _inner\n</code></pre>"},{"location":"library/reference/qref/","title":"qref","text":""},{"location":"library/reference/qref/#qref","title":"qref","text":"<p>Public API of QREF.</p>"},{"location":"library/reference/qref/#qref.SCHEMA_GENERATORS","title":"SCHEMA_GENERATORS  <code>module-attribute</code>","text":"<pre><code>SCHEMA_GENERATORS = {'v1': generate_schema_v1}\n</code></pre>"},{"location":"library/reference/qref/#qref.MODELS","title":"MODELS  <code>module-attribute</code>","text":"<pre><code>MODELS = {'v1': SchemaV1}\n</code></pre>"},{"location":"library/reference/qref/#qref.LATEST_SCHEMA_VERSION","title":"LATEST_SCHEMA_VERSION  <code>module-attribute</code>","text":"<pre><code>LATEST_SCHEMA_VERSION = 'v1'\n</code></pre>"},{"location":"library/reference/qref/#qref.SchemaV1","title":"SchemaV1","text":"<p>               Bases: <code>BaseModel</code></p> <p>Root object in Program schema V1.</p> Source code in <code>src/qref/schema_v1.py</code> <pre><code>class SchemaV1(BaseModel):\n    \"\"\"Root object in Program schema V1.\"\"\"\n\n    version: Literal[\"v1\"]\n    program: RoutineV1\n</code></pre>"},{"location":"library/reference/qref/#qref.SchemaV1.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: Literal['v1']\n</code></pre>"},{"location":"library/reference/qref/#qref.SchemaV1.program","title":"program  <code>instance-attribute</code>","text":"<pre><code>program: RoutineV1\n</code></pre>"},{"location":"library/reference/qref/#qref.verify_topology","title":"verify_topology","text":"<pre><code>verify_topology(\n    routine: RoutineV1,\n) -&gt; TopologyVerificationOutput\n</code></pre> <p>Checks whether program has correct topology.</p> <p>Correct topology cannot include cycles or disconnected ports.</p> <p>Parameters:</p> Name Type Description Default <code>routine</code> <code>RoutineV1</code> <p>Routine or program to be verified.</p> required Source code in <code>src/qref/verification.py</code> <pre><code>@accepts_all_qref_types\ndef verify_topology(routine: RoutineV1) -&gt; TopologyVerificationOutput:\n    \"\"\"Checks whether program has correct topology.\n\n    Correct topology cannot include cycles or disconnected ports.\n\n    Args:\n        routine: Routine or program to be verified.\n    \"\"\"\n    problems = _verify_routine_topology(routine)\n    return TopologyVerificationOutput(problems)\n</code></pre>"},{"location":"library/reference/qref/#qref.generate_program_schema","title":"generate_program_schema","text":"<pre><code>generate_program_schema(\n    version: str = LATEST_SCHEMA_VERSION,\n) -&gt; dict[str, Any]\n</code></pre> <p>Generate Program schema of given version.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>version identifier of the schema.</p> <code>LATEST_SCHEMA_VERSION</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary with JSON schema describing program.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>version</code> does not match any known version schema.</p> Source code in <code>src/qref/__init__.py</code> <pre><code>def generate_program_schema(version: str = LATEST_SCHEMA_VERSION) -&gt; dict[str, Any]:\n    \"\"\"Generate Program schema of given version.\n\n    Args:\n        version: version identifier of the schema.\n\n    Returns:\n        A dictionary with JSON schema describing program.\n\n    Raises:\n        ValueError: if `version` does not match any known version schema.\n    \"\"\"\n    try:\n        return SCHEMA_GENERATORS[version]()\n    except KeyError:\n        raise ValueError(f\"Unknown schema version {version}\")\n</code></pre>"},{"location":"library/reference/qref.schema_v1/","title":"qref.schema_v1","text":""},{"location":"library/reference/qref.schema_v1/#qref.schema_v1","title":"qref.schema_v1","text":"<p>Pydantic models used for defining V1 schema of Routine.</p>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.NAME_PATTERN","title":"NAME_PATTERN  <code>module-attribute</code>","text":"<pre><code>NAME_PATTERN = '[A-Za-z_][A-Za-z0-9_]*'\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.OPTIONALLY_NAMESPACED_NAME_PATTERN","title":"OPTIONALLY_NAMESPACED_NAME_PATTERN  <code>module-attribute</code>","text":"<pre><code>OPTIONALLY_NAMESPACED_NAME_PATTERN = (\n    f\"({NAME_PATTERN}\\.)?{NAME_PATTERN}\"\n)\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.MULTINAMESPACED_NAME_PATTERN","title":"MULTINAMESPACED_NAME_PATTERN  <code>module-attribute</code>","text":"<pre><code>MULTINAMESPACED_NAME_PATTERN = (\n    f\"({NAME_PATTERN}\\.)+{NAME_PATTERN}\"\n)\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.OPTIONALLY_MULTINAMESPACED_NAME_PATTERN","title":"OPTIONALLY_MULTINAMESPACED_NAME_PATTERN  <code>module-attribute</code>","text":"<pre><code>OPTIONALLY_MULTINAMESPACED_NAME_PATTERN = (\n    f\"({NAME_PATTERN}\\.)*{NAME_PATTERN}\"\n)\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.CONNECTION_PATTERN","title":"CONNECTION_PATTERN  <code>module-attribute</code>","text":"<pre><code>CONNECTION_PATTERN = f\"{OPTIONALLY_MULTINAMESPACED_NAME_PATTERN} -&gt; {OPTIONALLY_MULTINAMESPACED_NAME_PATTERN}\"\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T')\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.CONNECTION_SCHEMA","title":"CONNECTION_SCHEMA  <code>module-attribute</code>","text":"<pre><code>CONNECTION_SCHEMA = {\n    \"type\": \"array\",\n    \"items\": {\n        \"anyOf\": [\n            {\"$ref\": \"#/$defs/Connection\"},\n            {\n                \"pattern\": f\"^{CONNECTION_PATTERN}$\",\n                \"type\": \"string\",\n            },\n        ]\n    },\n    \"title\": \"Connections\",\n    \"type\": \"array\",\n}\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.NamedList","title":"NamedList","text":"<p>               Bases: <code>list[T]</code></p> Source code in <code>src/qref/schema_v1.py</code> <pre><code>class NamedList(list[T]):\n    @property\n    def by_name(self) -&gt; _ProxyMapping[T]:\n        return _ProxyMapping(self)\n\n    @classmethod\n    def __get_pydantic_core_schema__(cls, source, handler):\n        args = get_args(source)\n        schema = handler.generate_schema(list[args[0]])\n        return core_schema.no_info_after_validator_function(NamedList, schema)\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.NamedList.by_name","title":"by_name  <code>property</code>","text":"<pre><code>by_name: _ProxyMapping[T]\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.NamedList.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source, handler)\n</code></pre> Source code in <code>src/qref/schema_v1.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source, handler):\n    args = get_args(source)\n    schema = handler.generate_schema(list[args[0]])\n    return core_schema.no_info_after_validator_function(NamedList, schema)\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.PortV1","title":"PortV1","text":"<p>               Bases: <code>BaseModel</code></p> <p>Description of Port in V1 schema</p> Source code in <code>src/qref/schema_v1.py</code> <pre><code>class PortV1(BaseModel):\n    \"\"\"Description of Port in V1 schema\"\"\"\n\n    name: _Name\n    direction: Literal[\"input\", \"output\", \"through\"]\n    size: _Value | None\n    model_config = ConfigDict(title=\"Port\")\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.PortV1.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: _Name\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.PortV1.direction","title":"direction  <code>instance-attribute</code>","text":"<pre><code>direction: Literal['input', 'output', 'through']\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.PortV1.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: _Value | None\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.PortV1.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(title='Port')\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ConnectionV1","title":"ConnectionV1","text":"<p>               Bases: <code>BaseModel</code></p> <p>Description of Connection in V1 schema</p> Source code in <code>src/qref/schema_v1.py</code> <pre><code>class ConnectionV1(BaseModel):\n    \"\"\"Description of Connection in V1 schema\"\"\"\n\n    source: _OptionallyNamespacedName\n    target: _OptionallyNamespacedName\n\n    model_config = ConfigDict(title=\"Connection\", use_enum_values=True)\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ConnectionV1.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: _OptionallyNamespacedName\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ConnectionV1.target","title":"target  <code>instance-attribute</code>","text":"<pre><code>target: _OptionallyNamespacedName\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ConnectionV1.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    title=\"Connection\", use_enum_values=True\n)\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ResourceV1","title":"ResourceV1","text":"<p>               Bases: <code>BaseModel</code></p> <p>Description of Resource in V1 schema</p> Source code in <code>src/qref/schema_v1.py</code> <pre><code>class ResourceV1(BaseModel):\n    \"\"\"Description of Resource in V1 schema\"\"\"\n\n    name: _Name\n    type: Literal[\"additive\", \"multiplicative\", \"qubits\", \"other\"]\n    value: _Value | None\n\n    model_config = ConfigDict(title=\"Resource\")\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ResourceV1.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: _Name\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ResourceV1.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal[\n    \"additive\", \"multiplicative\", \"qubits\", \"other\"\n]\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ResourceV1.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: _Value | None\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ResourceV1.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(title='Resource')\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ParamLinkV1","title":"ParamLinkV1","text":"<p>               Bases: <code>BaseModel</code></p> <p>Description of Parameter link in V1 schema</p> Source code in <code>src/qref/schema_v1.py</code> <pre><code>class ParamLinkV1(BaseModel):\n    \"\"\"Description of Parameter link in V1 schema\"\"\"\n\n    source: _OptionallyNamespacedName\n    targets: list[_MultiNamespacedName]\n\n    model_config = ConfigDict(title=\"ParamLink\")\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ParamLinkV1.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: _OptionallyNamespacedName\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ParamLinkV1.targets","title":"targets  <code>instance-attribute</code>","text":"<pre><code>targets: list[_MultiNamespacedName]\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ParamLinkV1.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(title='ParamLink')\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ConstantSequenceV1","title":"ConstantSequenceV1","text":"<p>               Bases: <code>BaseModel</code></p> <p>Description of a constant sequence in a V1 Schema.</p> <p>In a constant sequence we repeat an element <code>multiplier</code> times in each iteration.</p> Source code in <code>src/qref/schema_v1.py</code> <pre><code>class ConstantSequenceV1(BaseModel):\n    \"\"\"Description of a constant sequence in a V1 Schema.\n\n    In a constant sequence we repeat an element `multiplier` times in each iteration.\n    \"\"\"\n\n    type: Literal[\"constant\"]\n    multiplier: _Value = 1\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ConstantSequenceV1.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['constant']\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ConstantSequenceV1.multiplier","title":"multiplier  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>multiplier: _Value = 1\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ArithmeticSequenceV1","title":"ArithmeticSequenceV1","text":"<p>               Bases: <code>BaseModel</code></p> <p>Description of an arithmetic sequence in a V1 Schema.</p> <p>In an arithmetic sequence we start from <code>initial_term</code> repetitions of an element, and in each iteration we increase it by <code>difference</code>.</p> Source code in <code>src/qref/schema_v1.py</code> <pre><code>class ArithmeticSequenceV1(BaseModel):\n    \"\"\"Description of an arithmetic sequence in a V1 Schema.\n\n    In an arithmetic sequence we start from `initial_term` repetitions of an element,\n    and in each iteration we increase it by `difference`.\n    \"\"\"\n\n    type: Literal[\"arithmetic\"]\n    initial_term: _Value = 0\n    difference: _Value\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ArithmeticSequenceV1.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['arithmetic']\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ArithmeticSequenceV1.initial_term","title":"initial_term  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>initial_term: _Value = 0\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ArithmeticSequenceV1.difference","title":"difference  <code>instance-attribute</code>","text":"<pre><code>difference: _Value\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.GeometricSequenceV1","title":"GeometricSequenceV1","text":"<p>               Bases: <code>BaseModel</code></p> <p>Description of a geometric sequence in a V1 Schema.</p> <p>In a geometric sequence we start from 1 repetition of an element, and in each iteration we multiply it by <code>ratio</code>.</p> Source code in <code>src/qref/schema_v1.py</code> <pre><code>class GeometricSequenceV1(BaseModel):\n    \"\"\"Description of a geometric sequence in a V1 Schema.\n\n    In a geometric sequence we start from 1 repetition of an element,\n    and in each iteration we multiply it by `ratio`.\n    \"\"\"\n\n    type: Literal[\"geometric\"]\n    ratio: _Value\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.GeometricSequenceV1.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['geometric']\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.GeometricSequenceV1.ratio","title":"ratio  <code>instance-attribute</code>","text":"<pre><code>ratio: _Value\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ClosedFormSequenceV1","title":"ClosedFormSequenceV1","text":"<p>               Bases: <code>BaseModel</code></p> <p>Description of a sequence with known closed-form for a sum or product in a V1 Schema.</p> <p>If <code>sum</code>/<code>prod</code> are specified, they can be used to calculate these values for a given sequence. Expressions for <code>sum</code>/<code>prod</code> should use <code>num_terms_symbol</code> to represent the total number of terms.</p> Source code in <code>src/qref/schema_v1.py</code> <pre><code>class ClosedFormSequenceV1(BaseModel):\n    \"\"\"Description of a sequence with known closed-form for a sum or product in a V1 Schema.\n\n    If `sum`/`prod` are specified, they can be used to calculate these values for a given sequence.\n    Expressions for `sum`/`prod` should use `num_terms_symbol` to represent the total number of terms.\n    \"\"\"\n\n    type: Literal[\"closed_form\"]\n    sum: _Value | None = None\n    prod: _Value | None = None\n    num_terms_symbol: str\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ClosedFormSequenceV1.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['closed_form']\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ClosedFormSequenceV1.sum","title":"sum  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sum: _Value | None = None\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ClosedFormSequenceV1.prod","title":"prod  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prod: _Value | None = None\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.ClosedFormSequenceV1.num_terms_symbol","title":"num_terms_symbol  <code>instance-attribute</code>","text":"<pre><code>num_terms_symbol: str\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.CustomSequenceV1","title":"CustomSequenceV1","text":"<p>               Bases: <code>BaseModel</code></p> <p>Description of a custom sequence in a V1 Schema.</p> <p>For sequences which do not fall into categories defined in other classes, one can use a custom representation. It is an explicit representation of a sequence where <code>term_expression</code> defines the expression for each term in the sequence and <code>iterator_symbol</code> is used to represent number of the iteration.</p> Source code in <code>src/qref/schema_v1.py</code> <pre><code>class CustomSequenceV1(BaseModel):\n    \"\"\"Description of a custom sequence in a V1 Schema.\n\n    For sequences which do not fall into categories defined in other classes, one can use a custom representation.\n    It is an explicit representation of a sequence where `term_expression` defines the expression for each term\n    in the sequence and `iterator_symbol` is used to represent number of the iteration.\n    \"\"\"\n\n    type: Literal[\"custom\"]\n    term_expression: str\n    iterator_symbol: str = \"i\"\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.CustomSequenceV1.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['custom']\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.CustomSequenceV1.term_expression","title":"term_expression  <code>instance-attribute</code>","text":"<pre><code>term_expression: str\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.CustomSequenceV1.iterator_symbol","title":"iterator_symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iterator_symbol: str = 'i'\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.RepetitionV1","title":"RepetitionV1","text":"<p>               Bases: <code>BaseModel</code></p> <p>Description of a repetition of a routine in V1 schema.</p> Source code in <code>src/qref/schema_v1.py</code> <pre><code>class RepetitionV1(BaseModel):\n    \"\"\"Description of a repetition of a routine in V1 schema.\"\"\"\n\n    count: int | str\n    sequence: ConstantSequenceV1 | ArithmeticSequenceV1 | GeometricSequenceV1 | ClosedFormSequenceV1 | CustomSequenceV1\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.RepetitionV1.count","title":"count  <code>instance-attribute</code>","text":"<pre><code>count: int | str\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.RepetitionV1.sequence","title":"sequence  <code>instance-attribute</code>","text":"<pre><code>sequence: (\n    ConstantSequenceV1\n    | ArithmeticSequenceV1\n    | GeometricSequenceV1\n    | ClosedFormSequenceV1\n    | CustomSequenceV1\n)\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.RoutineV1","title":"RoutineV1","text":"<p>               Bases: <code>BaseModel</code></p> <p>Description of Routine in V1 schema.</p> Note <p>This is NOT a top-level object in the schema. Instead, RoutineV1 is wrapped in SchemaV1.</p> Source code in <code>src/qref/schema_v1.py</code> <pre><code>class RoutineV1(BaseModel):\n    \"\"\"Description of Routine in V1 schema.\n\n    Note:\n        This is NOT a top-level object in the schema. Instead, RoutineV1 is wrapped in SchemaV1.\n    \"\"\"\n\n    name: _Name\n    children: Annotated[NamedList[RoutineV1], _name_sorter] = Field(default_factory=NamedList)\n    type: str | None = None\n    ports: Annotated[NamedList[PortV1], _name_sorter] = Field(default_factory=NamedList)\n    resources: Annotated[NamedList[ResourceV1], _name_sorter] = Field(default_factory=NamedList)\n    connections: Annotated[list[Annotated[ConnectionV1, _connection_parser]], _source_sorter] = []\n    input_params: list[_OptionallyMultiNamespacedName] = []\n    local_variables: dict[str, str] = {}\n    linked_params: Annotated[list[ParamLinkV1], _source_sorter] = []\n    repetition: RepetitionV1 | None = None\n    meta: dict[str, Any] = {}\n    model_config = ConfigDict(title=\"Routine\", validate_assignment=True)\n\n    def __init__(self, **data: Any):\n        super().__init__(**{k: v for k, v in data.items() if v != [] and v != {}})\n\n    @model_validator(mode=\"after\")\n    def _validate_connections(self) -&gt; Self:\n        children_port_names = [f\"{child.name}.{port.name}\" for child in self.children for port in child.ports]\n        parent_port_names = [port.name for port in self.ports]\n        available_port_names = set(children_port_names + parent_port_names)\n\n        missed_ports = [\n            port\n            for connection in self.connections\n            for port in (connection.source, connection.target)\n            if port not in available_port_names\n        ]\n        if missed_ports:\n            raise ValueError(\n                \"The following ports appear in a connection but are not \"\n                f\"among routine's port or their children's ports: {missed_ports}.\"\n            )\n        return self\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.RoutineV1.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: _Name\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.RoutineV1.children","title":"children  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>children: Annotated[NamedList[RoutineV1], _name_sorter] = (\n    Field(default_factory=NamedList)\n)\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.RoutineV1.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: str | None = None\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.RoutineV1.ports","title":"ports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ports: Annotated[NamedList[PortV1], _name_sorter] = Field(\n    default_factory=NamedList\n)\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.RoutineV1.resources","title":"resources  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resources: Annotated[\n    NamedList[ResourceV1], _name_sorter\n] = Field(default_factory=NamedList)\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.RoutineV1.connections","title":"connections  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>connections: Annotated[\n    list[Annotated[ConnectionV1, _connection_parser]],\n    _source_sorter,\n] = []\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.RoutineV1.input_params","title":"input_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>input_params: list[_OptionallyMultiNamespacedName] = []\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.RoutineV1.local_variables","title":"local_variables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>local_variables: dict[str, str] = {}\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.RoutineV1.linked_params","title":"linked_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>linked_params: Annotated[\n    list[ParamLinkV1], _source_sorter\n] = []\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.RoutineV1.repetition","title":"repetition  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>repetition: RepetitionV1 | None = None\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.RoutineV1.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, Any] = {}\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.RoutineV1.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    title=\"Routine\", validate_assignment=True\n)\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.RoutineV1.__init__","title":"__init__","text":"<pre><code>__init__(**data: Any)\n</code></pre> Source code in <code>src/qref/schema_v1.py</code> <pre><code>def __init__(self, **data: Any):\n    super().__init__(**{k: v for k, v in data.items() if v != [] and v != {}})\n</code></pre>"},{"location":"library/reference/qref.schema_v1/#qref.schema_v1.generate_schema_v1","title":"generate_schema_v1","text":"<pre><code>generate_schema_v1() -&gt; dict[str, Any]\n</code></pre> <p>Generate Routine schema V1.</p> <p>The schema is generated from DocumentRootV1 model, and then enriched with additional fields \"title\" and \"$schema\".</p> Source code in <code>src/qref/schema_v1.py</code> <pre><code>def generate_schema_v1() -&gt; dict[str, Any]:\n    \"\"\"Generate Routine schema V1.\n\n    The schema is generated from DocumentRootV1 model, and then enriched with\n    additional fields \"title\" and \"$schema\".\n    \"\"\"\n    return SchemaV1.model_json_schema(schema_generator=_GenerateV1JsonSchema)\n</code></pre>"}]}