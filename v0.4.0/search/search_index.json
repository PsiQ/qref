{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QREF","text":"<p>Quantum Resource Estimation Format (QREF) is an open format for representing quantum algorithms, optimized for usage in quantum resource estimation (QRE).</p> <ul> <li> <p> It's just JSON (or YAML)</p> <p>QREF's data format is built on top of JSON, which makes it easy to write and read.</p> <p> Learn more</p> </li> <li> <p> Cross-language support</p> <p>QREF's JSON schema can be used for data validation in any language.</p> </li> <li> <p> Python library</p> <p>QREF's Python package provides programmatic access to QREF's JSON schema and ready-to-use Pydantic models.</p> <p> See user guide</p> </li> <li> <p> Open Source, Apache 2.0</p> <p>QREF is licensed under the Apache 2.0 license and lives on GitHub.</p> <p> See QREF on GH\u00a0\u29c9</p> </li> </ul>"},{"location":"development/","title":"Development guide","text":""},{"location":"development/#setting-up-development-environment","title":"Setting up development environment","text":"<p>QREF uses Poetry\u00a0\u29c9 for managing dependencies. Therefore, we recommend you use Poetry to setup your environment. However, if you insist on not using Poetry, the more traditional way of using editable install with <code>pip</code> is still avaiable.</p>"},{"location":"development/#using-editable-install-with-poetry","title":"Using editable install with Poetry","text":"<p>To setup your development environment install poetry (if you don't have it yet):</p> <pre><code>pip install poetry\n</code></pre> <p>And then install the project and its dependencies:</p> <pre><code>poetry install\n</code></pre>"},{"location":"development/#using-editable-install-with-pip","title":"Using editable install with pip","text":"<p>You can also develop Poetry using <code>pip</code>:</p> <pre><code>pip install -e .\n</code></pre> <p>Warning</p> <p>If you are planning to add/modify dependencies of QREF, we highly recommend you use Poetry instead of pip editable install. Without Poetry, you will need to edit dependencies manually, which is very error-prone.</p>"},{"location":"development/#setting-up-docs-locally","title":"Setting up docs locally","text":"<p>In order to set up docs locally you need to have appropriate dependencies \u2013\u00a0they get instaled when running <code>poetry install</code> automatically. When done, please run:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"format/","title":"Data format","text":""},{"location":"format/#introduction","title":"Introduction","text":"<p>QREF format is a domain-specific language (DSL) for describing quantum algorithms built on top of JSON for the purpose of resource estimation.</p> <p>In QREF, the algorithms are described as programs comprising hierarchical, directed acyclic graph (henceforth hierarchical DAGs) of subroutines. Let's break down what this means:</p> <ul> <li>Hierarchical means that routines can be nested.</li> <li>Directed means that every edge connecting two routines also defines in which   direction the information flows between them.</li> <li>Acyclic means that traversing the graph along its edges (respecting their direction)   will never lead to visiting the same node twice.</li> </ul> <p>Besides specifying the connectivity between routines in the algorithms, the QREF format also specifies how to store information relevant to resource estimation, such as known and unknown resources, parameters that might affect them and how the parameters propagate in the algorithm's graph.</p> <p>Before describing the format in detail, let us first exemplify its usage on a simple program.</p>"},{"location":"format/#basic-example","title":"Basic example","text":"<p>In QREF, the quantum programs are represented as graphs. If you are not used to representing computations as graph, don't worry! Before describing QREF format, we'll demostrate how a simple circuit can be represented as a graph.</p> <p>Consider a hypothetical quantum program as depicted in the following circuit.</p> <p></p> <p>Let's forget for a while that the depicted algorithm doesn't make much sense. We can see that the circuit comprises two subroutines:</p> <ul> <li><code>subroutine_1</code> operating on a single-qubit register.</li> <li><code>subroutine_2</code> operating on a two-qubit register.</li> </ul> <p>We also labelled inputs to the subroutines as <code>in_0</code> and <code>in_1</code>, and the whole output of our program (i.e. combined outputs of both subroutines) as <code>out</code>.</p> <p>Representing such a circuit as a graph is straightforward, it might look like this:</p> <p></p> <p>As we can see, the graph contains both subroutines form the original circuit, and an artificially introduced <code>merge</code> operation used to combine outputs from the subprograms into one final outputs.</p> <p>Now that we have our graph, let's see how it can be represented in QREF format. As already mentioned, QREF format is built on top of JSON, so we can write QREF files in either JSON or YAML. For our examples, those might look as follows:</p> YAMLJSON <pre><code>version: v1\nprogram:\n  name: my_program\n  ports:\n    - { direction: input, name: in_0, size: 1 }\n    - { direction: input, name: in_1, size: 2 }\n    - { direction: output, name: out, size: 3 }\n  children:\n    - name: subroutine_1\n      ports:\n        - { direction: input, name: in, size: 1 }\n        - { direction: output, name: out, size: 1 }\n    - name: subroutine_2\n      ports:\n        - { direction: input, name: in, size: 2 }\n        - { direction: output, name: out, size: 2 }\n    - name: merge\n      ports:\n        - { direction: input, name: in_0, size: 1 }\n        - { direction: input, name: in_1, size: 2 }\n        - { direction: output, name: out, size: 3 }\n  connections:\n    - { source: in_0, target: subroutine_1.in }\n    - { source: in_1, target: subroutine_2.in }\n    - { source: subroutine_1.out, target: merge.in_1 }\n    - { source: subroutine_2.out, target: merge.in_0 }\n    - { source: merge.out, target: out }\n</code></pre> <pre><code>{\n  \"version\": \"v1\",\n  \"program\": {\n    \"name\": \"my_program\",\n    \"ports\": [\n      {\n        \"direction\": \"input\",\n        \"name\": \"in_0\",\n        \"size\": 1\n      },\n      {\n        \"direction\": \"input\",\n        \"name\": \"in_1\",\n        \"size\": 2\n      },\n      {\n        \"direction\": \"output\",\n        \"name\": \"out\",\n        \"size\": 3\n      }\n    ],\n    \"children\": [\n      {\n        \"name\": \"subroutine_1\",\n        \"ports\": [\n          {\n            \"direction\": \"input\",\n            \"name\": \"in\",\n            \"size\": 1\n          },\n          {\n            \"direction\": \"output\",\n            \"name\": \"out\",\n            \"size\": 1\n          }\n        ]\n      },\n      {\n        \"name\": \"subroutine_2\",\n        \"ports\": [\n          {\n            \"direction\": \"input\",\n            \"name\": \"in\",\n            \"size\": 2\n          },\n          {\n            \"direction\": \"output\",\n            \"name\": \"out\",\n            \"size\": 2\n          }\n        ]\n      },\n      {\n        \"name\": \"merge\",\n        \"ports\": [\n          {\n            \"direction\": \"input\",\n            \"name\": \"in_0\",\n            \"size\": 1\n          },\n          {\n            \"direction\": \"input\",\n            \"name\": \"in_1\",\n            \"size\": 2\n          },\n          {\n            \"direction\": \"output\",\n            \"name\": \"out\",\n            \"size\": 3\n          }\n        ]\n      }\n    ],\n    \"connections\": [\n      {\n        \"source\": \"in_0\",\n        \"target\": \"subroutine_1.in\"\n      },\n      {\n        \"source\": \"in_1\",\n        \"target\": \"subroutine_2.in\"\n      },\n      {\n        \"source\": \"subroutine_1.out\",\n        \"target\": \"merge.in_1\"\n      },\n      {\n        \"source\": \"subroutine_2.out\",\n        \"target\": \"merge.in_0\"\n      },\n      {\n        \"source\": \"merge.out\",\n        \"target\": \"out\"\n      }\n    ]\n  }\n}\n</code></pre> <p>Let's dissect our example. The top-level object has two mandatory properties:</p> <ul> <li><code>version</code>: Set to <code>v1</code> (which is the only version so far)</li> <li><code>program</code>: This contains the actual description of the program.</li> </ul> <p>So what do we have in a <code>program</code> object?</p> <ul> <li><code>name</code>: Mandatory name of the program, here set to the string <code>my_program</code>.</li> <li><code>ports</code>: A collection of ports. They roughly correspond to quantum registers.</li> <li><code>children</code>: A list of children, or subroutines, of the program.</li> <li><code>connections</code>: A list defining edges of our graph.</li> </ul>"},{"location":"format/#ports","title":"Ports","text":"<p>Let us first take a look at ports, like the first input port of our program:</p> <pre><code>{direction: input, name: in_0, size: 1}\n</code></pre> <p>Ports, like most other components in QREF, have names, which should be distinct among all ports of any given program (or subroutine). Each port also has direction, which can be either <code>input</code> or <code>output</code>. Finally, each port has size. In our simple scenario, all sizes are positive integers. However, QREF is not limited to them, and size of a port can be either:</p> <ul> <li>A positive integer.</li> <li>A symbol or symbolic expression (e.g. <code>N</code> or <code>2L + 1</code>)</li> <li>A <code>null</code>, signifying that the size of the port can be deduced from sizes of   other ports it is connected to (possibly transitively).</li> </ul>"},{"location":"format/#children","title":"Children","text":"<p>The <code>children</code> list comprises all subroutines of the program. Each entry has the same structure as the program itself (one could say that the schema of the <code>program</code> is recursive). In particular, each child should have a name (unique in the scope of their immediate parent) and some ports. They can also have connections, and their  own children.</p>"},{"location":"format/#connections","title":"Connections","text":"<p>The last component of any program (and most subroutines) are connections defining the edges of a graph. The <code>connections</code> field is a list of objects, each having <code>source</code> and <code>target</code>. Both <code>source</code> and <code>target</code> can either be:</p> <ul> <li>A name of the port of the program/subroutine the connection belongs to, i.e. <code>out_0</code></li> <li>A reference to a port of one of program/subroutine's direct children.   Such a reference is formatted as <code>child.port_name</code>.</li> </ul> <p>There are three types of connections:</p> <ul> <li>Connections joining two distinct children, e.g.   <pre><code>{source: subroutine_1.out, target: merge.in_1}\n</code></pre></li> <li>Connections joining a child and its parent. e.g.:   <pre><code>{source: in_0, target: subroutine_1.in}\n</code></pre>   or   <pre><code>{source: merge.out, target: out}\n</code></pre></li> <li>Connections joining input and output port of a parent, known as passthroughs.   There are no passthroughs in our simple example, but one could look like:   <pre><code>{source: in_0, target: out}\n</code></pre></li> </ul>"},{"location":"library/userguide/","title":"User guide","text":""},{"location":"library/userguide/#installation","title":"Installation","text":"<p>To install QREF Python package, clone QREF repository and install it as usual with <code>pip</code>:</p> <pre><code># Clone QREF repo (you can use HTTP link as well)\ngit clone git@github.com:PsiQ/qref.git\ncd qref\npip install .\n</code></pre> <p>Please note that to use rendering features you need a working graphviz\u00a0\u29c9 installation.</p>"},{"location":"library/userguide/#usage","title":"Usage","text":""},{"location":"library/userguide/#using-json-schema-for-validating-data-in-qref-format","title":"Using JSON schema for validating data in QREF format","text":"<p>JSON schema for QREF format can be obtained by calling <code>generate_program_schema</code> function. Such schema can be then used for validating user's input, e.g. using <code>jsonschema</code>\u00a0\u29c9 package:</p> <pre><code>from jsonschema import validate\nfrom qref import generate_program_schema\n\n# Hypothetical function loading your data as native Python dictionary.\ndata = load_some_program()\nschema = generate_program_schema()\n\n# This will raise if there are some validation errors.\nvalidate(schema, data)\n</code></pre>"},{"location":"library/userguide/#validation-using-pydantic-models","title":"Validation using Pydantic models","text":"<p>If you are familiar with Pydantic\u00a0\u29c9, you might find it easier to work with QREF Pydantic models instead of interacting with JSON schema directly. In the example below, we create an instance of <code>SchemaV1</code> model from validated data stored in QREF format:</p> <pre><code>from qref import SchemaV1\n\ndata = load_some_program()\n\n# This will raise if data is not valid\nprogram = SchemaV1.model_validate(data)\n</code></pre>"},{"location":"library/userguide/#topology-validation","title":"Topology validation","text":"<p>There can be cases where a program is correct from the perspective of Pydantic validation, but has incorrect topology. This includes cases such as:</p> <ul> <li>Disconnected ports</li> <li>Ports with multiple connections</li> <li>Cycles in the graph</li> </ul> <p>In order to validate whether the topology of the program is correct you can use <code>verify_topology</code> method. Here's a short snippet showing how one can verify their program and print out the problems (if any).</p> <pre><code>from qref.verification import verify_topology\n\nprogram = load_some_program()\n\nverification_output = verify_topology(program)\n\nif not verification_output:\n    print(\"Program topology is incorrect, due to the following issues:\")\n    for problem in verification_output.problems:\n        print(problem)\n</code></pre>"},{"location":"library/userguide/#rendering-qref-files-using-qref-render-experimental","title":"Rendering QREF files using <code>qref-render</code> (experimental)","text":"<p>Warning</p> <p>This feature is considered experimental and may occassionally produce incorrect results.</p> <p>QREF comes with a CLI tool for rendering hierarchical graphs of quantum algorithms. To render an algorithm stored in a file named <code>my_program.yaml</code> into a  file <code>my_program_graph.svg</code> run:</p> <pre><code>qref-render my_program.yaml my_program_graph.svg\n</code></pre> <p>The <code>qref-render</code> tool supports <code>yaml</code> and <code>json</code> input formats, and all output formats supported by graphviz\u00a0\u29c9.</p> <p>If, instead of using CLI, you'd like to invoke QREF's rendering capabilities from Python script, you can look at qref.experimental.rendering module which exposes experimental API for performing the same task as <code>qref-render</code>.</p>"},{"location":"library/reference/qref.experimental.rendering/","title":"qref.experimental.rendering","text":""},{"location":"library/reference/qref.experimental.rendering/#qref.experimental.rendering","title":"qref.experimental.rendering","text":"<p>Experimental visualization capabilities for QREF.</p> <p>Currently, the visualizations are done with graphviz, which does not suport hierarchical structures. Therefore, we have to use a somewhat hacky representation of our routines:</p> <ul> <li>The leaf nodes are drawn as a single graphviz node (this is not surprising) with   Mrecord shape. This allows to visually separate routine name from its ports.</li> <li>The non-leaf nodes are represented as clusters.</li> <li>Clusters can't use Mrecord shape, and so the ports are drawn as separate nodes.</li> <li>Input and output ports are grouped into subgraphs with the same rank, which     forces all inputs / all outputs to be placed in a single column.</li> </ul> <p>Because of the above dichotomy, care has to be taken when constructing edges. - If addressing port of a leaf, it must be specified as graphviz port, e.g:   \"root.child:in_0\" - If addressing port of a non-leaf, you use normal node reference, e.g:   \"root.child.in_0\"</p>"},{"location":"library/reference/qref.experimental.rendering/#qref.experimental.rendering.GRAPH_ATTRS","title":"GRAPH_ATTRS  <code>module-attribute</code>","text":"<pre><code>GRAPH_ATTRS = {'rankdir': 'LR', 'fontname': 'Helvetica'}\n</code></pre>"},{"location":"library/reference/qref.experimental.rendering/#qref.experimental.rendering.LEAF_NODE_KWARGS","title":"LEAF_NODE_KWARGS  <code>module-attribute</code>","text":"<pre><code>LEAF_NODE_KWARGS = {\n    \"shape\": \"Mrecord\",\n    \"style\": \"bold\",\n    \"color\": \"#0288f5\",\n    \"fontsize\": \"12\",\n}\n</code></pre>"},{"location":"library/reference/qref.experimental.rendering/#qref.experimental.rendering.PORT_NODE_KWARGS","title":"PORT_NODE_KWARGS  <code>module-attribute</code>","text":"<pre><code>PORT_NODE_KWARGS = {\n    \"style\": \"bold\",\n    \"color\": \"#ffa44a\",\n    \"fontsize\": \"10\",\n    \"shape\": \"circle\",\n}\n</code></pre>"},{"location":"library/reference/qref.experimental.rendering/#qref.experimental.rendering.PORT_GROUP_ATTRS","title":"PORT_GROUP_ATTRS  <code>module-attribute</code>","text":"<pre><code>PORT_GROUP_ATTRS = {'rank': 'same'}\n</code></pre>"},{"location":"library/reference/qref.experimental.rendering/#qref.experimental.rendering.CLUSTER_KWARGS","title":"CLUSTER_KWARGS  <code>module-attribute</code>","text":"<pre><code>CLUSTER_KWARGS = {'style': 'rounded'}\n</code></pre>"},{"location":"library/reference/qref.experimental.rendering/#qref.experimental.rendering.to_graphviz","title":"to_graphviz","text":"<pre><code>to_graphviz(\n    data: Union[dict, SchemaV1]\n) -&gt; graphviz.Digraph\n</code></pre> <p>Convert routine encoded with v1 schema to a graphviz DAG.</p> Source code in <code>src/qref/experimental/rendering.py</code> <pre><code>def to_graphviz(data: Union[dict, SchemaV1]) -&gt; graphviz.Digraph:\n    \"\"\"Convert routine encoded with v1 schema to a graphviz DAG.\"\"\"\n    data = _ensure_schema_v1(data)\n    dag = graphviz.Digraph(graph_attr=GRAPH_ATTRS)\n    _add_routine(data.program, dag)\n    return dag\n</code></pre>"},{"location":"library/reference/qref.experimental.rendering/#qref.experimental.rendering.render_entry_point","title":"render_entry_point","text":"<pre><code>render_entry_point()\n</code></pre> Source code in <code>src/qref/experimental/rendering.py</code> <pre><code>def render_entry_point():\n    parser = ArgumentParser()\n    parser.add_argument(\n        \"input\", help=\"Path to the YAML or JSON file with Routine in V1 schema\", type=Path\n    )\n    parser.add_argument(\n        \"output\",\n        help=(\n            \"Path to the output file. File format is determined based on the extension, \"\n            \"which should be either .svg or .pdf\"\n        ),\n        type=Path,\n    )\n\n    args = parser.parse_args()\n\n    with open(args.input) as f:\n        routine = SchemaV1.model_validate(yaml.safe_load(f))\n\n    dag = to_graphviz(routine)\n    dag.render(args.output.with_suffix(\"\"), format=args.output.suffix.strip(\".\"))\n</code></pre>"},{"location":"library/reference/qref/","title":"qref","text":""},{"location":"library/reference/qref/#qref","title":"qref","text":"<p>Public API of QREF.</p>"},{"location":"library/reference/qref/#qref.SchemaV1","title":"SchemaV1","text":"<p>             Bases: <code>BaseModel</code></p> <p>Root object in Program schema V1.</p> Source code in <code>src/qref/_schema_v1.py</code> <pre><code>class SchemaV1(BaseModel):\n    \"\"\"Root object in Program schema V1.\"\"\"\n\n    version: Literal[\"v1\"]\n    program: RoutineV1\n</code></pre>"},{"location":"library/reference/qref/#qref.SchemaV1.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: Literal['v1']\n</code></pre>"},{"location":"library/reference/qref/#qref.SchemaV1.program","title":"program  <code>instance-attribute</code>","text":"<pre><code>program: RoutineV1\n</code></pre>"},{"location":"library/reference/qref/#qref.generate_program_schema","title":"generate_program_schema","text":"<pre><code>generate_program_schema(\n    version: str = LATEST_SCHEMA_VERSION,\n) -&gt; dict[str, Any]\n</code></pre> <p>Generate Program schema of given version.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>version identifier of the schema.</p> <code>LATEST_SCHEMA_VERSION</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary with JSON schema describing program.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>version</code> does not match any known version schema.</p> Source code in <code>src/qref/__init__.py</code> <pre><code>def generate_program_schema(version: str = LATEST_SCHEMA_VERSION) -&gt; dict[str, Any]:\n    \"\"\"Generate Program schema of given version.\n\n    Args:\n        version: version identifier of the schema.\n\n    Returns:\n        A dictionary with JSON schema describing program.\n\n    Raises:\n        ValueError: if `version` does not match any known version schema.\n    \"\"\"\n    try:\n        return SCHEMA_GENERATORS[version]()\n    except KeyError:\n        raise ValueError(f\"Unknown schema version {version}\")\n</code></pre>"}]}